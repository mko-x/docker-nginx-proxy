# Generated nginx site conf
{{/* MAPPING of configuration env vars to file globals avoiding problems within nested env access. */}}

{{/* Default vals where necessary */}}
{{ $infix := "" }}
{{ $autoRedirectEnabled := "0" }}
{{ $prefix := "" }}
{{ $forceSSL := "1" }}
{{ $spdyEnabled := "0" }}
{{ $allowHttp := "0" }}
{{ $port := "none" }}
{{ $upIdleConnections := "0" }}

{{/* Global env var assignments */}}
{{ $secLimitConsPerIp := .Env.GLOB_LIMIT_CONS_PER_IP }}
{{ $secLimitReqsBurst := .Env.GLOB_LIMIT_REQS_BURST }}
{{ $infix := .Env.GLOB_SSL_CERT_BUNDLE_INFIX }}
{{ $autoRedirectEnabled := .Env.GLOB_AUTO_REDIRECT_ENABLED }}
{{ $prefix := .Env.GLOB_AUTO_REDIRECT_PREFIX }}

{{ $spdyEnabled := .Env.GLOB_SPDY_ENABLED }}

{{ $unavailableService := .Env.GLOB_HTTP_NO_SERVICE }}
{{ $autoRedirectDirection := .Env.GLOB_AUTO_REDIRECT_DIRECTION }}

{{ $sslSessionTimeout := .Env.GLOB_SSL_SESSION_TIMEOUT }}
{{ $sslSessionCache := .Env.GLOB_SSL_SESSION_CACHE }}
{{ $forceSSL := .Env.GLOB_HTTPS_FORCE }}

{{ $sslOcspValidTime := .Env.GLOB_SSL_OCSP_VALID_TIME }}
{{ $sslOcspDnsAdresses := .Env.GLOB_SSL_OCSP_DNS_ADDRESSES }}
{{ $sslOcspDnsTimeout := .Env.GLOB_SSL_OCSP_DNS_TIMEOUT }}

{{ $allowHttp := .Env.GLOB_ALLOW_HTTP_FALLBACK }}

{{ $upIdleConnections := .Env.GLOB_UPSTREAM_IDLE_CONNECTIONS }}

## configuration input check
# bundled infix: {{.Env.GLOB_SSL_CERT_BUNDLE_INFIX}}
# redirect prefix: {{.Env.GLOB_AUTO_REDIRECT_PREFIX}}
# redirect direction: {{.Env.GLOB_AUTO_REDIRECT_DIRECTION}}

# spdy enabled: {{.Env.GLOB_SPDY_ENABLED}}
# unavailable service code: {{.Env.GLOB_HTTP_NO_SERVICE}}
# ssl session timeout: {{.Env.GLOB_SSL_SESSION_TIMEOUT}}
# ssl session cache size: {{.Env.GLOB_SSL_SESSION_CACHE}}


## configuration data
# bundled infix: {{$infix}}
# auto redirect: {{$autoRedirectEnabled}}
# redirect prefix: {{$prefix}}
# redirect direction: {{$autoRedirectDirection}}

# unavailable service code: {{$unavailableService}}
# ssl session timeout: {{$sslSessionTimeout}}
# ssl session cache size: {{$sslSessionCache}}

map $http_x_forwarded_proto $proxy_x_forwarded_proto {
  default $http_x_forwarded_proto;
  ''      $scheme;
}

map $http_upgrade $proxy_connection {
  default upgrade;
  ''      close;
}

gzip_types text/plain text/css application/javascript application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

log_format vhost '$host $remote_addr - $remote_user [$time_local] '
                 '"$request" $status $body_bytes_sent '
                 '"$http_referer" "$http_user_agent"';

access_log /proc/self/fd/1 vhost;
error_log /proc/self/fd/2;

client_max_body_size {{ .Env.GLOB_MAX_BODY_SIZE }};

proxy_http_version 1.1;
proxy_buffering off;
proxy_set_header Host $http_host;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection $proxy_connection;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
proxy_set_header X-Forwarded-Proto $proxy_x_forwarded_proto;

# Catching any if there is no real hostname
server {
        listen 80;
        server_name _;
        return {{ $unavailableService }};
}

{{/* MAIN VIRTUAL_HOST generation. */}}
{{ range $hostAndPort, $containers := groupByMulti $ "Env.VIRTUAL_HOST" "," }}
    {{ $hostAndPortArray := split $hostAndPort ":" }}
    {{ $host := first $hostAndPortArray }}
    {{ $path := replace $hostAndPort $host "" 1 }}
    
    {{ $hostAndPortLen := len $hostAndPortArray }}
    {{ if gt $hostAndPortLen 1 }}
        {{ $port := last $hostAndPortArray }}
        {{ $port := first ( split $port "/" ) }}
        {{ $path := replace $path $port "" 1 }}
        {{ $path := replace $path ":" "" 1 }}
    {{ end }}

    upstream {{ $host }} {

    {{/* UPSTREAM GENERATION. */}}
    {{ range $container := $containers }}

    	{{ $addrLen := len $container.Addresses }}
    
        {{/* ADDRESSING SWITCH CASE. */}}
    
    	{{ if eq $addrLen 1 }}
    	{{/* Address/Port count == 1, use the only one */}}
    
    		{{ with $address := index $container.Addresses 0 }}
            # {{$container.Name}}.single-port
            server {{ $address.IP }}:{{ $address.Port }}{{ $path }};
    		{{ end }}
        {{ else if ne $port "none" }}
        {{/* Address/Port count != 1, target port via ':' seperator provided */}}

            {{ range $address := .Addresses }}

                {{ if eq $address.Port $port }}
                    # {{$container.Name}}.virtual-port-from-host
                    server {{ $address.IP }}:{{ $address.Port }}{{ $path }};
                {{ end }}

        	{{ end }}
    	{{ else if $container.Env.VIRTUAL_PORT }}
        {{/* Port count != 1, VIRTUAL_PORT found, use given */}}
    
    		{{ range $address := .Addresses }}
        
    		   {{ if eq $address.Port $container.Env.VIRTUAL_PORT }}
            # {{$container.Name}}.virtual-port-from-env
            server {{ $address.IP }}:{{ $address.Port }}{{ $path }};
    		   {{ end }}
           
    		{{ end }}
	
    	{{ else }}
        {{/* Try to fall back to standard web port 80  */}}
        	{{ range $address := $container.Addresses }}

                {{ if eq $address.Port "80" }}

                    # {{$container.Name}}.fallback
                    server {{ $address.IP }}:{{ $address.Port }}{{ $path }};
                    {{ $foundhttp := "true" }}
                {{ end }}

            {{/* $container.Addresses end */}}
    		{{ end }}

        {{/* ADRESSING SWITCH. end */}}
    	{{ end }}
    
        {{/* Keep idle connections to upstream services, so there is no need for TCP handshaking latency etc.*/}}
        {{ if ne $upIdleConnections "0" }}
            keepalive {{ $upIdleConnections }};
        {{ end }}
        
    {{/* UPSTREAM GENERATION. end */}}
    {{ end }}
    }

    {{/* Get the VIRTUAL_PROTO defined by containers w/ the same vhost, falling back to "http" */}}
    {{ $proto := or (first (groupByKeys $containers "Env.VIRTUAL_PROTO")) "http" }}

    {{/* Get the first cert name defined by containers w/ the same vhost */}}
    {{ $certName := (first (groupByKeys $containers "Env.CERT_NAME")) }}

    {{/* Get the best matching cert by name for the vhost. */}}
    {{ $vhostCert := (closest (dir "/etc/nginx/certs") (printf "%s.crt" $host))}}

    {{/* vhostCert is actually a filename so remove any suffixes since they are added later */}}
    {{ $vhostCert := replace $vhostCert ".crt" "" -1 }}
    {{ $vhostCert := replace $vhostCert ".key" "" -1 }}

    {{/* Use the cert specifid on the container or fallback to the best vhost match */}}
    {{ $cert := (coalesce $certName $vhostCert) }}

    {{/* MAIN server configuration task. */}}
    {{ if (and (ne $cert "") (exists (printf "/etc/nginx/certs/%s.crt" $cert)) (exists (printf "/etc/nginx/certs/%s.key" $cert))) }}
    {{/* Valid HTTPS certificate and key files found. */}}

        {{ if eq $autoRedirectEnabled "1" }}

        server {
            
            {{/* Security limits */}}
            limit_conn perip {{ $secLimitConsPerIp }};
            limit_req zone=persec burst={{$secLimitReqsBurst }} nodelay;
            
            {{ if eq $autoRedirectDirection "0" }}
            {{/* Redirect prefixed host to plain host via moved permanently */}}
    
                server_name  {{ $prefix }}.{{ $host }};
                listen 443 ssl;
                rewrite ^(.*) https://{{ $host }}$1 permanent;
    
            {{ else }}
            {{/* Redirect non-prefixed host to prefixed host via moved permanently */}}
    
                server_name {{ $host }};
                listen 443 ssl;
                rewrite ^(.*) https://{{ $prefix }}.{{ $host }}$1 permanent;
    
            {{/* AUTO_REDIRECT_DIRECTION end */}}
            {{ end }}
        }

        {{/* AUTO_REDIRECT_WITH_PREFIX_ENABLED end */}}
        {{ end }}

        {{ if (and (eq $forceSSL "1") (eq $allowHttp "0")) }}
        {{/* Enforce https, redirect http */}}
            server {
                    server_name {{ $host }};
                    rewrite ^(.*) https://{{ $host }}$1 permanent;
            }
        {{ end }}

        {{ if eq $allowHttp "1" }}
        server {
                server_name {{ $host }};
                listen 80;
                
                {{/* Handle static file serving if requested by container */}}
                {{ range $uriAndTarget := groupByMulti $containers "Env.VIRTUAL_STATIC_FILE_CONFIG" "," }}

                    {{/* Allow custom seperators due to regex */}}
                    {{ $uriAndTargetArray := split $uriAndTarget $seppi }}
                
                    {{/* The location URI/regex to look for */}}
                    {{ $uri := $uriAndTargetArray[0] }}
                    {{/* The target path/URL to redirect to */}}
                    {{ $target := $uriAndTargetArray[1] }}
                    {{/* The kind of link (default) alias, root or proxy_pass */}}
                    {{ $kind := or ( $uriAndTargetArray[2] "root" ) }}

                    {{/* Add the internal location */}}
                    location {{ $uri }} {
                        internal;
                        {{ $kind }}: {{ $target }};
                    }
            
                {{ end }}
                
                location / {
                        proxy_pass {{ $proto }}://{{ $host }};
                
                        {{ if (exists (printf "/etc/nginx/htpasswd/%s" $host)) }}
                            auth_basic "Provide authentication for {{ $host }}";
                            auth_basic_user_file	{{ (printf "/etc/nginx/htpasswd/%s" $host) }};
                        {{ end }}
                }

                
        }
        {{ end }}

        {{/* SSL handling server */}}
        server {
                {{/* Security limits */}}
                limit_conn perip {{ $secLimitConsPerIp }};
                limit_req zone=persec burst={{$secLimitReqsBurst}} nodelay;
                
                server_name {{ $host }};
    
                {{/* SPDY effect 1 */}}
                {{ if eq $spdyEnabled "1" }}
                    listen 443 ssl spdy;
                {{ else }}
                    listen 443 ssl;
                {{ end }}
    
                ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
                ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-SHA:ECDHE-RSA-RC4-SHA;

                ssl_prefer_server_ciphers on;
                ssl_session_timeout {{ $sslSessionTimeout }};
                ssl_session_cache shared:SSL:{{ $sslSessionCache }};

                {{/* Support for Online Certificate Status Protocol (OCSP)/Stapling */}}
                {{ if ne $sslOcspValidTime "0" }}
                    ssl_stapling on;
                    ssl_stapling_verify on;
                    resolver {{ $sslOcspDnsAdresses }} valid={{ $sslOcspValidTime }};
                    resolver_timeout {{ $sslOcspDnsTimeout }};
                {{ end }} {{/* OCSP */}}

                {{ $certBundle := replace "ccii" "cc" $cert -1 }}
                {{ $certBundle := replace $certBundle "ii" $infix -1 }}

                ssl_certificate /etc/nginx/certs/{{ (printf "%s.crt" $certBundle) }};
                ssl_certificate_key /etc/nginx/certs/{{ (printf "%s.key" $cert) }};

                {{/* SPDY effect 2 */}}
                {{ if eq $spdyEnabled "1" }}
                    add_header Alternate-Protocol  443:npn-spdy/3;
                {{ end }}
        
                add_header Strict-Transport-Security "max-age=31536000; includeSubdomains";
                add_header X-Content-Type-Options nosniff;

                {{/* Custom include handling */}}
                {{ if (exists (printf "/etc/nginx/vhost.d/%s" $host)) }}
                    include {{ printf "/etc/nginx/vhost.d/%s" $host }};
                {{ end }}

                {{/* Handle static file serving if requested by container */}}
                {{ range $uriAndTarget := groupByMulti $containers "Env.VIRTUAL_STATIC_FILE_CONFIG" "," }}

                    {{/* Allow custom seperators due to regex */}}
                    {{ $seppi := or (first (groupByKeys $containers "Env.VIRTUAL_STATIC_CONFIG_ITEM_SEPERATOR")) ">" }}
                    {{ $uriAndTargetArray := split $uriAndTarget $seppi }}
            
                    {{/* The location URI/regex to look for */}}
                    {{ $uri := $uriAndTargetArray[0] }}
                    {{/* The target path/URL to redirect to */}}
                    {{ $target := $uriAndTargetArray[1] }}
                    {{/* The kind of link (default) alias, root or proxy_pass */}}
                    {{ $kind := or ( $uriAndTargetArray[2] "root" ) }}

                    {{/* Add the internal location */}}
                    location {{ $uri }} {
                        internal;
                        {{ $kind }}: {{ $target }};
                    }
        
                {{ end }}

                location / {
            
                    {{/* Pass with proto optionally to provide forcing connection to backend via protocol like HTTPS if necessary */}}
                    proxy_pass {{ $proto }}://{{ $host }};
            
                    {{/* Add basic auth if htpasswd dir contains a file named like the host */}}
                    {{ if (exists (printf "/etc/nginx/htpasswd/%s" $host)) }}
                        auth_basic "Provide authentication for {{ $host }}";
                        auth_basic_user_file	{{ (printf "/etc/nginx/htpasswd/%s" $host) }};
                    {{ end }}
                }
                
        }

    {{/* Valid HTTPS certificate and key files found. end */}}
    {{ else }} 
    {{/* Defaulting to HTTP. */}}

        {{ if eq $autoRedirectEnabled "1" }}

            server {
                {{ if eq $autoRedirectDirection "0" }}
    
                    server_name  {{ $prefix }}.{{ $host }};
                    rewrite ^(.*) http://{{ $host }}$1 permanent;
   
                {{ else }}
    
                    server_name {{ $host }};
                    rewrite ^(.*) http://{{ $prefix }}.{{ $host }}$1 permanent;
    
                {{ end }}
            }

        {{/* AUTO_REDIRECT_WITH_PREFIX_ENABLED end. */}}
        {{ end }}

        {{/* HTTP proxy */}}
        server {
                {{ if (and ($.Env.DEFAULT_HOST) (eq $.Env.DEFAULT_HOST $host) ) }}
            	    listen 80 default_server;
            	    server_name {{ $host }};
            	{{ else }}
            	  server_name {{ $host }};
            	{{ end }}

                {{/* Security limits */}}
                limit_conn perip {{ $secLimitConsPerIp }};
                limit_req zone=persec burst={{$secLimitReqsBurst }} nodelay;

                {{ if (exists (printf "/etc/nginx/vhost.d/%s" $host)) }}
                    include {{ printf "/etc/nginx/vhost.d/%s" $host }};
                {{ end }}

                {{/* Handle static file serving if requested by container */}}
                {{ range $uriAndTarget := groupByMulti $containers "Env.VIRTUAL_STATIC_FILE_CONFIG" "," }}

                    {{/* Allow custom seperators due to regex */}}
                    {{ $seppi := or (first (groupByKeys $containers "Env.VIRTUAL_STATIC_CONFIG_ITEM_SEPERATOR")) ">" }}
                    {{ $uriAndTargetArray := split $uriAndTarget $seppi }}
            
                    {{/* The location URI/regex to look for */}}
                    {{ $uri := $uriAndTargetArray[0] }}
                    {{/* The target path/URL to redirect to */}}
                    {{ $target := $uriAndTargetArray[1] }}
                    {{/* The kind of link (default) alias, root or proxy_pass */}}
                    {{ $kind := or ( $uriAndTargetArray[2] "root" ) }}

                    {{/* Add the internal location */}}
                    location {{ $uri }} {
                        internal;
                        {{ $kind }}: {{ $target }};
                    }
        
                {{ end }}

                location / {
                        proxy_pass {{ $proto }}://{{ $host }};
                
                        {{ if (exists (printf "/etc/nginx/htpasswd/%s" $host)) }}
                            auth_basic "Provide authentication for {{ $host }}";
                            auth_basic_user_file	{{ (printf "/etc/nginx/htpasswd/%s" $host) }};
                        {{ end }}
                }
                
                
        }

        {{ if (and (exists "/etc/nginx/certs/default.crt") (exists "/etc/nginx/certs/default.key")) }}
            server {
                    server_name {{ $host }};
                    listen 443 ssl;
                    return {{ $unavailableService }};

                    ssl_certificate /etc/nginx/certs/default.crt;
                    ssl_certificate_key /etc/nginx/certs/default.key;
            }
        {{ end }}

    {{/* MAIN server configuration task. end */}}
    {{ end }}

{{/* MAIN VIRTUAL_HOST generation. end */}}
{{ end }}
